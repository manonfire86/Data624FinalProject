---
title: "Final Project"
author: "Hector Santana, Harris Dupre, Christopher Ayre"
date: "5/9/2022"
output: html_document
---

Our initial step is to import the relevant libraries containing the requisite models of this analysis.

```{r libraries}

library(mlbench)
library(randomForest)
library(caret)
library(party)
library(Cubist)
library(dplyr)
library(rpart.plot)
library(kernlab)
library(earth)
library(nnet)
library(DataExplorer)
library(RANN)
library(corrplot)
pacman::p_load(tidyverse,janitor,DataExplorer,knitr,arsenal,kableExtra,car,geoR,caret,
               psych,gridExtra,DMwR2,lmtest,pscl,MKmisc,ROCR,survey,stats,rstatix,Rcpp,
               corrplot,forecast,cowplot)

library(mice)



```

To create ease around the data importation process we converted the excel files into CSV and stored them in a GitHub repository.

```{r Importation}


studenttrainingdata = read.csv('https://raw.githubusercontent.com/manonfire86/Data624FinalProject/main/StudentData.csv')

studenttestdata = read.csv('https://raw.githubusercontent.com/manonfire86/Data624FinalProject/main/StudentEvaluation.csv')

```

The below exploratory analysis indicates that missing values are fairly low. For our model to be robust and dynamic we will impute missing data, filter out correlations, near zero variables, scale the data, and center the data in our preprocess methodology.



```{r}
str(studenttrainingdata)
```

```{r}
summary(studenttrainingdata)
```

```{r}
dim(studenttrainingdata)
```


```{r dataexploration}
df_features <- studenttrainingdata %>%
  dplyr::select(-c(`Brand.Code`))

correlation = cor(df_features, use = 'pairwise.complete.obs')
corrplot(correlation, 'ellipse', type = 'lower', order = 'hclust',
         col=brewer.pal(n=8, name="RdYlBu"))

mice_plot <- aggr(studenttrainingdata, col=c('navyblue','yellow'),
                    numbers=TRUE, sortVars=TRUE,
                    labels=names(studenttrainingdata), cex.axis=.7,
                    gap=3, ylab=c("Missing data","Pattern"))




plot_missing(studenttrainingdata)
plot_histogram(studenttrainingdata)
plot_density(studenttrainingdata)
plot_boxplot(
  data = studenttrainingdata,
  by = "PH")



```




```{r datatransformation}

set.seed(100)

studentrainingdata <- studenttrainingdata[complete.cases(studenttrainingdata$PH),]
preprocess_data_model = preProcess(studenttrainingdata, c("center", "scale", "knnImpute", "corr", "nzv"))
new_dataset = predict(preprocess_data_model,studenttrainingdata)


```

We will now split our data into a training and validation to analyze model outputs.

```{r validation}

training_partition = createDataPartition(new_dataset$PH,p=.8,list=FALSE)

training_df = new_dataset[training_partition,]
validation_df = new_dataset[-training_partition,]


```


We will now build models using various linear, nonlinear, and tree based approaches.

# Linear Models

##Ordinary Least Regression

```{r models}

olrmod = train(PH~.,data = training_df,method='lm',trControl=trainControl('cv',number=10))

olrpred = predict(olrmod,validation_df)
olrpred_results = postResample(pred = olrpred, obs = validation_df$PH)


```

##Partial Least Squares

```{r model2}

pls_mod = train(PH~.,data = training_df,method='pls',trControl=trainControl('cv',number=10),center=T,tunelength=20)

plot(pls_mod)

plspred = predict(pls_mod,validation_df)
plspred_results = postResample(pred = plspred, obs = validation_df$PH)


```


#Ridge Regression


```{r model3}
set.seed(100)

rrfit = train(PH~.,data=training_df,method='ridge',tuneGrid=data.frame(.lambda=seq(0,.1,length=15)),trControl=trainControl('cv',number=10))

plot(rrfit)

rrpred = predict(rrfit,validation_df)
rrpred_results = postResample(pred = rrpred, obs = validation_df$PH)


```






##Non Linear Models

#Neural Networks

```{r model4}

set.seed(100)
nnetmod = train(PH~.,data=training_df,
                  method = "avNNet",
                  preProc = c("center", "scale"),
                  tuneGrid = expand.grid( .decay = c(0, 0.01, .1), .size = c(1:10), .bag= F ),
                  trControl = trainControl(method = "cv",number = 10),
                  linout = T,
                  trace= F,
                  MaxNWts = 5 * (ncol(training_df) + 1) + 5 + 1,
                  maxit = 500)

nnetpred = predict(nnetmod,validation_df)
nnetpred_results = postResample(pred = nnetpred, obs = validation_df$PH)


```



#MARS

```{r model5}

set.seed(100)
marsmod = train(PH~.,data=training_df,method='earth',trControl=trainControl(method='cv'))

marspred = predict(marsmod,validation_df)
marspred_results = postResample(pred = marspred, obs = validation_df$PH)


```



#SVM
```{r model6}
set.seed(100)
svmmod = train(PH~., data = training_df,
               method= "svmLinear",
               trControl = trainControl(method = "repeatedcv",number = 10, repeats=3),
               tuneLength = 10)

svmpred = predict(svmmod,validation_df)
svmpred_results = postResample(pred = svmpred, obs = validation_df$PH)


```


#KNN


```{r model7}

set.seed(100)
knnmod = train(PH~., data = training_df,
               method= "knn",
               trControl = trainControl(method = "repeatedcv",number = 10, repeats=3),
               tuneLength = 10)

knnpred = predict(knnmod,validation_df)
knnpred_results = postResample(pred = knnpred, obs = validation_df$PH)

```

## Display Model Results

```{r}
titles <- list("OLR","PLS","RR","NNet","MARS","SVM","KNN")
results <- list(olrpred_results,plspred_results,rrpred_results,nnetpred_results,marspred_results,svmpred_results,knnpred_results)

df = NULL
for (x in 1:length(results)) {
  Model = titles[[x]]
  RMSE = unname(results[[x]]["RMSE"])
  Rsquared = unname(results[[x]]["Rsquared"])
  MAE = unname(results[[x]]["MAE"])
    
  df = rbind(df,data.frame(Model,RMSE,Rsquared,MAE))
}

knitr::kable(df[order(df$Rsquared,decreasing=FALSE),], digits=4, row.names=F)
```